# YCloud 企业级智能云文件系统 - 混合搜索推荐引擎子模块

## 模块概述

YCloud 智能网盘系统是一款面向企业级用户的高性能云存储解决方案，本文档重点介绍其文本识别搜索与推荐引擎子模块的设计与实现。该子模块基于高并发架构，为用户提供关键词推荐、文本文档检索、内容预览等智能功能，与核心网盘功能无缝集成。实现异构CUDA加速文件文本OCR识别添加文本标签。

## 技术架构

### 1. 高并发服务框架

- **Epoll事件驱动模型**：采用封装epoll和线程池高性能服务后端Reactor事件通知机制，多线程异步计算，统一返回
- **父子进程架构**：优化信号处理机制，父进程负责信号监听，子进程负责业务处理
- **线程池技术**：实现资源复用，降低线程创建/销毁开销，支持大规模并发请求

### 2. 云文件核心功能

- **远程文件操作**：支持 cd, ls, pwd, tree 等命令，实现远程目录浏览与管理
- **文件传输**：支持 puts/gets 命令进行高效文件上传/下载，针对大文件传输优化
- **文件管理**：支持 remove 命令递归删除文件/目录

### 3. 图像与PDF智能识别功能

- **检测与识别**：使用改进的DBNet精确定位文档中的文本区域，采用CRNN准确识别检测到的文本内容
- **C++集成与CUDA加速**：我们使用TensorRT引擎将训练好的PyTorch模型转换为优化后的推理模型，并通过C++ API封装为高性能的服务组件
- **文本标签**：将识别得到的文本和文件路径封装到文本偏移库，供快速查找检索

### 3. 智能搜索引擎

- **分词与索引**：基于 cppjieba 实现中文智能分词，构建倒排索引
- **关键词推荐**：实现关键词智能联想功能计算最短编辑距离，提升用户搜索效率
- **文本检索**：支持按内容检索文档，返回包含关键词的相关段落，以及加权特征下最相似文章



## 系统实现细节


```

- **父子进程通信**：通过管道实现父子进程间通信，父进程监听 SIGUSR1 信号，通过管道通知子进程优雅退出
- **线程池管理**：子进程维护线程池，根据 Epoll 就绪事件分配任务，实现高效的并发处理

### 网络传输协议

- **小火车协议**：自定义传输协议，每次发送 `<长度头>+<数据内容>`，解决 TCP 粘包问题
- **安全传输**：send 操作添加 MSG_NOSIGNAL 标志，避免因客户端断开连接导致服务进程异常退出
- **大文件优化**：针对大文件传输进行分块处理，确保传输稳定性和效率

### 搜索引擎实现

- **离线索引构建**：系统启动时预构建索引，支持实时更新
- **分词系统**：
  - 英文单词使用空格和标点划分，中文使用专业分词库
  - 停用词过滤，提高检索质量
  - 数字与特殊字符处理
- **单例模式**：WordQuery 类采用线程安全的单例模式，优化多线程环境下的资源使用

## 工程实践经验

### 关键技术难点及解决方案

1. **高并发下的稳定性**
   - 问题：客户端突然断开连接导致 SIGPIPE 信号，造成线程异常退出
   - 解决：给 send 添加 MSG_NOSIGNAL 标志，避免进程因 SIGPIPE 信号终止

2. **大文件传输的完整性**
   - 问题：TCP 粘包导致数据读取错位，文件内容损坏
   - 解决：实现带长度头的传输协议，确保数据边界清晰

3. **线程资源管理**
   - 问题：线程资源浪费与上下文切换开销
   - 解决：实现生产者/消费者模型的线程池，优化资源利用

### 性能优化

- **无锁查询设计**：WordQuery 对象的 query 方法设计为只读操作，多线程环境下无需加锁
- **线程本地存储**：每个线程维护独立的客户端状态信息，避免锁竞争
- **批量数据处理**：文件内容检索采用批量处理策略，减少 I/O 操

**高并发的远程文件**:客户端远程访问可以查看文件目录，下载/上传文件。服务端高并发响应多个客户端的响应。


**服务端/客户端父子进程多线程架构**：

服务端退出：由于SIGUSR1(Ctrl+C)信号量对线程支持不好容易造成死锁，所以父进程fork得到子进程。父子进程通过管道通讯，父进程监听SIGUSR1(Ctrl+C)信号，当检测到信号时候通过管道发放消息给子进程。子进程监听pipe[0]设置线程池程序退出变量runningFlag，信号量唤醒等待线程然后退出线程，还在人物的线程任务完成后检测到退出变量则退出线程，子进程join得到所有线程结束，父进程wait等待子进程结束。

**高并发监听**：Epoll红黑数管理增加删除监听，O(1)检测就绪事件，对比就绪队列，监听socket当检测到就绪时候accept新的newfd添加到任务队列中。监听exitPipe[0]设置退出变量runningFlag。

**任务队列/线程池=生产者/消费者模型**：任务队列结构体包含任务头节点，尾节点，任务数量和信号量。当监听到新的客户端，上锁添加任务socket到任务队列通知等待线程，解锁。设计线程池，减少线程创建消灭以减少时间的消耗，我们在factory_s结构体中的存储线程数组的空间中创造numThread个线程，执行threadFun函数，每个函数保存一份客户端信息clientFd和独立当前路径currentPath，阻塞在wait，上锁判断任务数量如果等于0则等待信号量的唤醒，如果不等于0则取出任务，线程与客户端的newFd通讯，解锁。

**传输**：对于指令和短消息的传输设计train_s结构体包含datalength和buf字符数组。因为传输是流式的，所以先接受一个sizeof(int)的字符数组长度，再接受指定长度的字符数组数据，避免少读或者多读而造成数据偏移。为了读取length长度的数据可以使用参数WAITALL，或者封装send/recv函数得到sendn/recvn发送或者接受长度数据。sendTrain构建train结构体发送一整个train结构体也就是sizeof(int)长度和字符数据。sendFile和recvFiles首先发送/接受train文件名，然后循环传输文件内容train，send要添加NOSIGNAL避免客户端socket关闭而触发SIGPIPE而导致程序退出。 

**命令**：cd命令改变线程局部路径，ls返回当前路径下的文件，pwd显示当前路径，puts上传文件，gets下载文件，remove移除文件或者递归移除目录，tree返回树状文件。

## **开发中的问题**：

**1.**   **高并发下 send 报错，导致子线程异常退出**

背景：在高并发下，客户端有时候会突然断开，服务器线程还在 send。

遇到的问题：send 返回 -1，errno 是 EPIPE，线程直接因为收到 SIGPIPE 信号被杀死，导致线程池里面线程数量减少。

解决方法：给 send 加 MSG_NOSIGNAL 标志位。或者统一设置 signal(SIGPIPE, SIG_IGN); 忽略这个信号。

**2. 大文件传输中 TCP 粘包问题**

背景：实现网盘上传/下载功能，小火车协议。

遇到的问题：发送文件内容时出现粘包，导致客户端读到的数据出现偏移，文件内容错误。

解决方法：自定义传输协议，**每次发送一个"长度头" + "数据内容"**。客户端使用 recvn() 保证接收完整的指定长度数据。

**3. pthread_cleanup_push pthread_cleanup_pop**

该空间是一个局部空间，局部空间申明的变量无法在外部使用，查询后函数实现方式式宏替换，会产生一个花括号的局部作用域。
** 4.	服务端快速重启**
服务端退出后，有一段TIME_WAIT的时间段，此时重启出现，Address already in use,对监听fd设置reuse避免等待，可以快速重启服务端。
进程公用一个路径，多线程每个共用一个path出现../../这种
空白字符问题，数字分词问题，中英文问题。Utf-8中文字符处理
